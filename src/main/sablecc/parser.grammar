Package compiler;

Helpers
    sp = ' ';
    lf = 0x000a;
    cr = 0x000d;
    ff = 0x000c;
    ht = 0x0009;
    line_terminator = lf | cr | cr lf;
    whitespace = (sp | ht | ff | line_terminator)*;

    all = [0..0xffff];
    letter = [['a'..'z'] + ['A'..'Z']];
    digit = ['0'..'9'];
    hexadecimal_digit = digit | ['a'..'f'] | ['A'..'F'];
    hexadecimal_literal = ('x' | 'X') hexadecimal_digit hexadecimal_digit;
    escape_sequence = '\n' | '\t' | '\r' | '\0' | '\\' | '\' ''' | '\"' | hexadecimal_literal;
    common_char = [all - [[''' + '"'] + '\']];
    char_part = common_char | escape_sequence;
    not_dollar = [all - '$'];
    not_dollar_line_terminator = [all - ['$' + [lf + cr]]];
    not_line_terminator = [all - [lf + cr]];

Tokens
    and = 'and';
    char = 'char';
    div = 'div';
    do = 'do';
    else = 'else';
    fun = 'fun';
    if = 'if';
    int = 'int';
    mod = 'mod';
    not = 'not';
    nothing = 'nothing';
    or = 'or';
    ref = 'ref';
    return = 'return';
    then = 'then';
    var = 'var';
    while = 'while';

    plus = '+';
    minus = '-';
    times = '*';
    hash = '#';
    equal = '=';
    less = '<';
    greater = '>';
    less_equal = '<=';
    greater_equal = '>=';

    lparen = '(';
    rparen = ')';
    lsquare_bracket = '[';
    rsquare_bracket = ']';
    lbracket = '{';
    rbracket = '}';
    comma = ',';
    semicolon = ';';
    colon = ':';
    left_arrow = '<-';

    identifier = letter (letter | digit | '_')*;
    int_constant = digit+;
    char_constant = ''' char_part ''';
    string = '"' ([common_char - [lf + cr]] | escape_sequence)+ '"';

    line_comment = '$' (line_terminator | (not_dollar_line_terminator not_line_terminator* line_terminator));
    block_comment = '$$' not_dollar* '$' (not_dollar not_dollar* '$')* '$';
    whitespace = whitespace;

Ignored Tokens
    whitespace, line_comment, block_comment;

Productions
    program = func_def;
    func_def = header local_def* block;

    another_fpar_def = semicolon fpar_def;
    one_or_more_fpar_def = fpar_def another_fpar_def*;
    header = fun identifier lparen one_or_more_fpar_def? rparen colon return_type;


    fpar_def = ref? identifier another_identifier* colon fpar_type;
    data_type = {int} int
              | {char} char
              ;

    array_size = lsquare_bracket int_constant rsquare_bracket;
    type = data_type array_size*;
    return_type = data_type
             | {nothing} nothing
             ;

    empty_cell = lsquare_bracket rsquare_bracket;
    fpar_type = data_type empty_cell? array_size*;
    local_def = {func_def} func_def
              | {func_decl} func_decl
              | {var_def} var_def
              ;

    another_identifier = comma identifier;
    var_def = var identifier another_identifier* colon type semicolon;
    func_decl = header semicolon;

    /* Statements */
    statement = {open} open_statement
              | {matched} matched_statement
              ;

    matched_statement = {with_else} if cond then [left]:matched_statement else [right]:matched_statement
                      | {loop} while cond do matched_statement
                      | {other} other_statement
                      ;

    open_statement = {without_else} if cond then statement
                   | {with_else} if cond then matched_statement else open_statement
                   | {loop} while cond do open_statement
                   ;

    other_statement = {null} semicolon
                    | {assignment} l_value left_arrow expr semicolon
                    | {func_call} func_call semicolon
                    //| {loop} while cond do statement
                    | {return} return expr? semicolon
                    | {block} block
                    ;

    block = lbracket statement* rbracket;

    /* Function call */
    another_argument = comma expr;
    arguments = expr another_argument*;
    func_call = identifier lparen arguments? rparen;

    /* L-value */
    l_value = l_value lsquare_bracket expr rsquare_bracket
            | {id} identifier
            | {string} string
            ;

    /* Conditions */
    cond = {disj} cond or conj
         | {other} conj
         ;

    conj = conj and neg
         | {other} neg
         ;

    neg = not neg
        | {other} numeric_cond
        ;

    numeric_cond = {equal} [left]:expr equal [right]:expr
                 | {not_equal} [left]:expr hash [right]:expr
                 | {greater} [left]:expr greater [right]:expr
                 | {less} [left]:expr less [right]:expr
                 | {greater_equal} [left]:expr greater_equal [right]:expr
                 | {less_equal} [left]:expr less_equal [right]:expr
                 | {paren} lparen cond rparen
                 ;

    /* Expressions */
    expr = {add} expr plus term
         | {sub} expr minus term
         | {other} term
         ;

    term = {mult} term times factor
         | {div} term div factor
         | {mod} term mod factor
         | {other} factor
         ;

    factor = {positive} plus const
           | {negative} minus const
           | {other} const
           ;

    const = {l_value} l_value
          | {int} int_constant
          | {char} char_constant
          | {paren} lparen expr rparen
          | func_call
          ;
