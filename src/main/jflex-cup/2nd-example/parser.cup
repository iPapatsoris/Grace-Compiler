/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;

/**
 *  Usercode Components
 */
parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**
 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal            AND, CHAR, DIV, DO, ELSE, FUN, IF,
                    INT, MOD, NOT, NOTHING, OR, REF, RETURN,
                    THEN, VAR, WHILE,
                    PLUS, MINUS, TIMES, HASH, EQ, NEQ,
                    LESS, GREATER, LESSEQ, GREATEREQ,
                    LPAREN, RPAREN, LSQR, RSQR, LBRACK, RBRACK,
                    COMMA, SEMICOLON, COLON, LARROW, ID,
                    SIGN;
terminal String     STRING_LITERAL;
terminal Integer    INT_CONST;
terminal Character  CHAR_CONST;

/*  Non terminals */
non terminal            expr_list, expr_part;
non terminal Integer    expr;
non terminal Boolean    cond;

/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence left SIGN;

/* The grammar */
expr_list ::= expr_list expr_part
	          |
              expr_part;

expr_part ::= expr:e
	          {: System.out.println("= " + e); :}
              SEMICOLON
	          ;

expr      ::= expr:e1 PLUS expr:e2
	          {: RESULT = e1 + e2; :}
	          |
              expr:e1 MINUS expr:e2
              {: RESULT = e1 - e2; :}
	          |
              expr:e1 TIMES expr:e2
	          {: RESULT = e1 * e2; :}
	          |
              expr:e1 DIV expr:e2
	          {: RESULT = e1 / e2; :}
	          |
              expr:e1 MOD expr:e2
	          {: RESULT = e1 % e2; :}
	          |
              MINUS expr:e
	          {: RESULT = 0 - e; :}
	          %prec SIGN
	          |
              PLUS expr:e
              {: RESULT = e; :}
              %prec SIGN
              |
              LPAREN expr:e RPAREN
	          {: RESULT = e; :}
              |
              INT_CONST:n
              {: RESULT = n; :}
              |
              CHAR_CONST:n
              {: RESULT = (int)n; :}
              ;
